"use strict";(self.webpackChunkdoks=self.webpackChunkdoks||[]).push([[7706],{36301:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var t=i(85893),s=i(11151);i(15944);const a={title:"Why not Kafka?",sidebar_label:"Kafka?",sidebar_position:1},r=void 0,o={id:"design/why-not/rest",title:"Why not Kafka?",description:"Why not Rest?",source:"@site/docs/design/why-not/rest.mdx",sourceDirName:"design/why-not",slug:"/design/why-not/rest",permalink:"/docs/design/why-not/rest",draft:!1,unlisted:!1,editUrl:"https://github.com/jhnnsrs/doks/edit/master/docs/design/why-not/rest.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Why not Kafka?",sidebar_label:"Kafka?",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Kafka?",permalink:"/docs/design/why-not/kafka"},next:{title:"Configuration",permalink:"/docs/design/configuration"}},l={},h=[{value:"Why not Rest?",id:"why-not-rest",level:2},{value:"Why we like GraphQL",id:"why-we-like-graphql",level:2},{value:"Challenges of using GraphQL",id:"challenges-of-using-graphql",level:2}];function d(e){const n={a:"a",admonition:"admonition",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"why-not-rest",children:"Why not Rest?"}),"\n",(0,t.jsx)(n.p,{children:"When deciding on the API for Arkitekt, we considered using REST, but ultimately decided on GraphQL. Here are some reasons why we chose GraphQL over REST:"}),"\n",(0,t.jsx)(n.h2,{id:"why-we-like-graphql",children:"Why we like GraphQL"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Flexibility"}),": With GraphQL, clients can specify exactly what data they need, reducing over-fetching or under-fetching of data.\nFor bioimage analysis, where datasets can be large and complex, this ensures efficient data retrieval."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Strongly Typed"}),": GraphQL is strongly typed. This means that the shape and type of the response are known in advance,\nwhich can be particularly useful in bioimage analysis where ensuring data integrity and consistency is crucial. Also it allows you\nto use the full power of your IDE to explore the API."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Evolution of your Schema"}),": As bioimage analysis techniques and tools evolve, the data structure and requirements might change.\nGraphQL allows for the addition of new fields and types without impacting existing queries, ensuring backward compatibility."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Aggregated Data"}),": Often in bioimage analysis, data from multiple sources or related entities need to be fetched.\nGraphQL allows for fetching data from multiple sources in a single query, simplifying client-side data aggregation. With\n",(0,t.jsx)(n.strong,{children:"soon to be implemened"})," federation, you can even fetch data from different Arkitekt services in a single query."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Real-time Updates"}),": With subscriptions in GraphQL, clients can be notified in real-time when certain data changes.\nThis can be invaluable in bioimage analysis when monitoring the progress or outcomes of certain analyses (e.g in streaminganalysis)"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Self-documenting"}),": GraphQL APIs come with introspection capabilities, making it easier for developers to understand the available data, types, queries, and mutations, t\nhereby fostering faster and more accurate development. Just check the GraphIQL interface of your Arkitekt server."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Ecosystem & Tooling"}),": The growing popularity of GraphQL has led to a rich ecosystem of tools, libraries, and client-side frameworks.\nThis can speed up development and offer advanced features for bioimage analysis data servers out of the box. Indeed a lot of the Arkitektl\nclient libraries are build around this ecosystem (e.g. ",(0,t.jsx)(n.a,{href:"https://the-guild.dev/graphql/codegen",children:"graphql-codegen"})," and ",(0,t.jsx)(n.a,{href:"https://github.com/jhnnsrs/turms",children:"turms"}),")"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Developing with GraphQL",type:"note",children:(0,t.jsxs)(n.p,{children:["Developing a Python or Typescript client that interfaces with our GraphQL API is easy and fun. We have outlined the steps in the ",(0,t.jsx)(n.a,{href:"/docs/developer/helpers/developing-with-graphql",children:"Developing with GraphQL"})," section,\nwhich utilizes some of the tools and libraries mentioned above."]})}),"\n",(0,t.jsx)(n.h2,{id:"challenges-of-using-graphql",children:"Challenges of using GraphQL"}),"\n",(0,t.jsx)(n.p,{children:"While we believe that GraphQL is a great fit for bioimage analysis, it is not without its challenges. Here are some of the challenges we have encountered:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learning Curve"}),": GraphQL has a steeper learning curve compared to REST, especially for developers who are new to it. However, we believe that the benefits of GraphQL outweigh the initial learning curve,\nand our tooling should help to make the transition easier."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Caching"}),": Caching in GraphQL can be more complex than in REST, especially when dealing with complex queries and mutations. While we employ a number of strategies to mitigate this, it is still an area that requires careful consideration."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"N + 1 Problem"}),": The N + 1 problem occurs when a query results in multiple requests to the server to fetch related data, and can lead to performance issues.In REST, the N + 1 problem can be mitigated by using endpoints that return the exact data needed. In GraphQL, this problem can be exacerbated by the flexibility of the API.\nHowever, we have implemented a number of strategies to mitigate this problem, such as dataloader and federation and especially our new strawberrry based implementation, comes with a lot of performance improvements."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Security"}),": While GraphQL provides a lot of flexibility, it also introduces new security challenges. For example, clients can craft complex queries that can lead to performance issues or even denial of service attacks. Our new APIs\nhave implemented a number of strategies to mitigate these risks, such as query complexity analysis and rate limiting."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Work in progress",type:"note",children:(0,t.jsx)(n.p,{children:"This section is still work in progress."})})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);