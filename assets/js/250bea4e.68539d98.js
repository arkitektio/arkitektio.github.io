(self.webpackChunkdoks=self.webpackChunkdoks||[]).push([[8927],{38828:(e,t,a)=>{e.exports={src:{srcSet:a.p+"assets/ideal-img/graphql.b34cf1d.640.png 640w,"+a.p+"assets/ideal-img/graphql.6033f7c.1320.png 1320w,"+a.p+"assets/ideal-img/graphql.6a991ae.2000.png 2000w",images:[{path:a.p+"assets/ideal-img/graphql.b34cf1d.640.png",width:640,height:319},{path:a.p+"assets/ideal-img/graphql.6033f7c.1320.png",width:1320,height:657},{path:a.p+"assets/ideal-img/graphql.6a991ae.2000.png",width:2e3,height:995}],src:a.p+"assets/ideal-img/graphql.b34cf1d.640.png",toString:function(){return a.p+"assets/ideal-img/graphql.b34cf1d.640.png"},placeholder:void 0,width:640,height:319},preSrc:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2ElEQVQImQHNADL/ACozRPYWHzH6e4CJ4////+v27PTy+fD28v///+tqcX7cJy9A+zA4R7oAKDFC/xYfMf+BhI7v/////Pr3+f/08PL///75+25yf+woMEH/MThHxwAmL0D+HSU3/3Bveu6qq6j5u4yr/7mIpf/FxMT5jYqZ6ycvQP8tNUXFACUtPf4cJTb/TU9Z7WJlYfl/RW3/o2GN/9/Z2/luc3/pJjBA/zA3R8UALjVE/iAoOP97fojs/vv7+ebj5//u6u//////+GxxfegvN0b/Nj1Nxa4JenezzjysAAAAAElFTkSuQmCC"}},79403:(e,t,a)=>{"use strict";a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>m,frontMatter:()=>l,metadata:()=>h,toc:()=>u});var i=a(83117),s=(a(67294),a(3905)),r=a(15944),o=a(38828),n=a.n(o);const l={id:"graphql",title:"GraphQL",sidebar_label:"GraphQL",sidebar_position:1},d="GraphQL",h={unversionedId:"features/graphql",id:"features/graphql",title:"GraphQL",description:"Quite a lot of modern image analysis tools, especially those based on deep learning, are designed to run on GPUs. Arkitekt aims",source:"@site/docs/features/graphql.mdx",sourceDirName:"features",slug:"/features/graphql",permalink:"/docs/features/graphql",draft:!1,editUrl:"https://github.com/jhnnsrs/doks/edit/master/docs/features/graphql.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"graphql",title:"GraphQL",sidebar_label:"GraphQL",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Features",permalink:"/docs/category/features"},next:{title:"GPU Support",permalink:"/docs/features/intro"}},p={},u=[{value:"Schema",id:"schema",level:2},{value:"Why we like GraphQL",id:"why-we-like-graphql",level:2},{value:"Relational",id:"relational",level:3},{value:"React developer? Try it out Here",id:"react-developer-try-it-out-here",level:2}],c={toc:u},g="wrapper";function m(e){let{components:t,...a}=e;return(0,s.kt)(g,(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"graphql"},"GraphQL"),(0,s.kt)("p",null,"Quite a lot of modern image analysis tools, especially those based on deep learning, are designed to run on GPUs. Arkitekt aims\nto make it easy to use these tools, and to make it easy to run them on GPUs. However there are a few things to be aware of, as\nArkitekt is not a magical solution to all GPU problems."),(0,s.kt)("h2",{id:"schema"},"Schema"),(0,s.kt)("p",null,"There are two different ways to use GPUs with Arkitekt. The first is to use the GPU support built into the standalone tools themselves and\non their hardware. This is probably the case when this tool exists primarily outside of the Arkitekt ecosystem, and Arkitekt is just being used to bridge it.\nYou can then just connect this tool like any other tool, and Arkitekt will run in on the connecting tool and hardware."),(0,s.kt)("p",null,"The second way is to use the GPU support built into Arkitekt itself. This is the case when the tool is designed to run inside Arkitekt as a PluginApp. See more\nin the ",(0,s.kt)("a",{parentName:"p",href:"/docs/developer"},"developer")," section on how to build an Arkitekt plugin. Here Arkitekt uses the docker support system to run the plugin in a docker container\nwithin the Arkitekt server.  "),(0,s.kt)("h1",{id:"what-does-this-boil-down-to"},"What does this boil down to?"),(0,s.kt)("div",{className:"mt-2 w-20"},(0,s.kt)(r.Z,{img:n(),mdxType:"Image"}),(0,s.kt)("div",{className:"text-gray-400 mb-2"},(0,s.kt)("small",null,"How the Arkitekt server can manage GPU access. (Adapted from the NVIDIA Container Toolkit Documentatoin) . Containers run in a sandbodex environment and request GPU access from the underlying service (docker engine). This "))),(0,s.kt)("h2",{id:"why-we-like-graphql"},"Why we like GraphQL"),(0,s.kt)("p",null,"Ask a developer about API design and you'll probably get an earful about which paradigm to use. REST, SOAP, RPC, and GraphQL are all popular choices.\nWe chose GraphQL for Arkitekt because it's a modern, flexible, and powerful way to design APIs that deal with relational and federated data in a type-safe way.\nLets look at these in more detail."),(0,s.kt)("h3",{id:"relational"},"Relational"),(0,s.kt)("p",null,"Modern image analysis relies heavily on relational data "),(0,s.kt)("h2",{id:"react-developer-try-it-out-here"},"React developer? Try it out Here"),(0,s.kt)("p",null,"We can talk ages about the ease of use of graphql. But you can try it out yourself. Here is a simple example of a React component that uses graphql to fetch data from yur local Arkitekt server.\nYou can just change the query to fetch any data you want."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function Display(props) {\n  const { data } = useMikroQuery(\n    gql`\n      query {\n        representations(limit: 3) {\n          id\n          name\n          store\n          shape\n        }\n      }\n    `\n  );\n\n  return (\n    <div className="flex flex-col gap-2">\n      {data && data.representations.map((image) => <div className="bg-green-200">{image.name} </div>)}\n    </div>\n  );\n}\n')))}m.isMDXComponent=!0}}]);