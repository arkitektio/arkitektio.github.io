"use strict";(self.webpackChunkdoks=self.webpackChunkdoks||[]).push([[2182],{11255:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var n=a(85893),i=a(11151);const o={id:"my-first-app",title:"Read and Write",sidebar_label:"Read and Write"},r="Read and Write",s={id:"developers/python/basics/my-first-app",title:"Read and Write",description:"Imaging you have some data that you want to store in Arkitekt. This could be a microscopy image, a segmented image, or any other data that you want to store. In this tutorial we will show you how to store this data in Arkitekt.",source:"@site/docs/developers/python/basics/read-write.md",sourceDirName:"developers/python/basics",slug:"/developers/python/basics/my-first-app",permalink:"/docs/developers/python/basics/my-first-app",draft:!1,unlisted:!1,editUrl:"https://github.com/jhnnsrs/doks/edit/master/docs/developers/python/basics/read-write.md",tags:[],version:"current",frontMatter:{id:"my-first-app",title:"Read and Write",sidebar_label:"Read and Write"},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/docs/category/basics"},next:{title:"Classic",permalink:"/docs/category/classic"}},l={},h=[{value:"What we will cover",id:"what-we-will-cover",level:2},{value:"Understanding Mikro",id:"understanding-mikro",level:2},{value:"Upload some data",id:"upload-some-data",level:2},{value:"About that line of code",id:"about-that-line-of-code",level:2},{value:"Illustration of the upload process",id:"illustration-of-the-upload-process",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"read-and-write",children:"Read and Write"}),"\n",(0,n.jsx)(t.p,{children:"Imaging you have some data that you want to store in Arkitekt. This could be a microscopy image, a segmented image, or any other data that you want to store. In this tutorial we will show you how to store this data in Arkitekt."}),"\n",(0,n.jsx)(t.h2,{id:"what-we-will-cover",children:"What we will cover"}),"\n",(0,n.jsx)(t.p,{children:"In this tutorial we will cover the following topics:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Understanding Mikro"}),"\n",(0,n.jsx)(t.li,{children:"Creating an image on Arkitekt"}),"\n",(0,n.jsx)(t.li,{children:"Where is my data stored"}),"\n",(0,n.jsx)(t.li,{children:"Getting data from Arkitekt"}),"\n",(0,n.jsx)(t.li,{children:"Working with big data on Arkitekt"}),"\n",(0,n.jsx)(t.li,{children:"Associating metadata with your data"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"understanding-mikro",children:"Understanding Mikro"}),"\n",(0,n.jsxs)(t.p,{children:["Mikro is Arkitekts storage system, and one of the core components of Arkitekt. You can use it to store, explore and organize your bioimage data. Backed by\na relational database and a s3 compatible object store, Mikro is designed for you to manage datasets of any size. If you are familiar with omero you can think of Mikro as the Arkitekt version of omero. Instead of providing a web interface, Mikro provides only a comprehensive GraphQL API that you can use to interact with your data. For more information on Mikro, see the ",(0,n.jsx)(t.a,{href:"/docs/services/mikro.md",children:"Mikro documentation"}),". When interacting with Mikro through python, we can use the mikro client, that is a module of the arkitekt client, and provides some additional convenience methods to make the python ecosystem of\npandas, numpy and xarray work well with Mikro."]}),"\n",(0,n.jsx)(t.h2,{id:"upload-some-data",children:"Upload some data"}),"\n",(0,n.jsx)(t.p,{children:"Lets start with the simplest example. Imaging you have a numpy array that you want to store in Arkitekt. For this testing purpose we will create a random numpy array."}),"\n",(0,n.jsx)(t.p,{children:"Lets first look at what code we need to upload the data to Arkitekt."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from arkitekt import easy\nfrom mikro.api.schema import from_xarray\nimport xarray as xr\nimport numpy as np\n\napp = easy("my-app-name")\n\ni = np.random.rand(100,100,1)\nimage_data = xr.DataArray(i, dims=["x", "y", "c"])\n\nwith app:\n   image = from_xarray(image_data, name="Random image") # stores the xarray on the mikro instance of the governing app context\n   print(image.data)\n'})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["First we create an through the easy function. Find a more detailed explanation of the easy function in the ",(0,n.jsx)(t.a,{href:"/docs/developers/python/Intro",children:"Intro"})," tutorial. By default the easy configuration will ask for the scopes ",(0,n.jsx)(t.code,{children:"read"})," and ",(0,n.jsx)(t.code,{children:"write"}),". So we will be able to read and write data to the app."]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["We would advise you to use the ",(0,n.jsx)(t.code,{children:"easy"})," function to create an app. This function will automatically create a new app (uniquely belong to you) if it does not exist yet. If the app already exists, it will return the existing app. This is useful if you want to use the same app in multiple scripts."]})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"We create a random numpy array with the shape (100,100,1). This is equivalent to an 100x100 image with one channel."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["We create an xarray from the numpy array. As mikros datamodel of images is based on xarray, it is necessary and best practice to create an xarray from your data before uploading it to mikro. If you are not familiar with xarray, we recommend that you take a look at the ",(0,n.jsx)(t.a,{href:"http://xarray.pydata.org/en/stable/",children:"xarray documentation"}),". You might notice that we are using the ",(0,n.jsx)(t.code,{children:"dims"})," argument to specify the dimensions of the xarray. This labels the axis of the numpy array. In this case we have an image with the dimensions ",(0,n.jsx)(t.code,{children:"x"}),", ",(0,n.jsx)(t.code,{children:"y"})," and ",(0,n.jsx)(t.code,{children:"c"}),". The ",(0,n.jsx)(t.code,{children:"c"})," dimension is the channel dimension, and is used to store multiple channels in one image. If you have an image with only one channel, you can omit the ",(0,n.jsx)(t.code,{children:"c"})," dimension."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"We enter the app context, from now on we are able to call the functionality on the connected arkitekt server"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["In this one line of code we will create an Arkitekt image from the xarray. This will upload the data to the object store and create a new image in the database. The ",(0,n.jsx)(t.code,{children:"name"})," argument is optional, but it is good practice to give your data a name. This will make it easier to find your data later on. The call of\nthis function will return an ",(0,n.jsx)(t.code,{children:"Image"})," object. This object is local representation of an object on the arkitekt instance. It contains all the information about the image, and can be used to access the data."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["When accessing the image data we will have to use the ",(0,n.jsx)(t.code,{children:"data"})," attribute of the image object. Which will be a lazy array that will only loaded from the object store when needed (using dask and zarr to minimize the amount of data that needs to be loaded from the object store)."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"about-that-line-of-code",children:"About that line of code"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'image = from_xarray(image_data, name="Random image")\nprint(image.data)\n'})}),"\n",(0,n.jsx)(t.p,{children:"These two lines of code is a bit more complex than the other lines of code in this tutorial. Lets take a look at what is happening here."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["We are calling the ",(0,n.jsx)(t.code,{children:"from_xarray"})," function from the ",(0,n.jsx)(t.code,{children:"mikro.api.schema"})," module. This function is a convenience function that will in turn call the apps mikro services api, with the given parameters. Lets inspect these parameters on their way to the server:"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"illustration-of-the-upload-process",children:"Illustration of the upload process"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["image_data is an xr.DataArray with the dims 'x', 'y' and 'z'. This is the data that we want to store on the server. When storing images however, arkitekt\nexpects the data to have the dims x,y,z,t and c. Which is a strict requirement of the server to accept the data, ensuring consistency for consuming. As it is a common use case to store images that do not fullfill all dimensions, the ",(0,n.jsx)(t.code,{children:"from_xarray"})," function will automatically add the missing dimensions to the data, by expanding the array."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The GraphQL API indeed does not accept xarray objects, but only JSON serializable objects. But we can't just serialize a numpy array to JSON, as this will result in a very large JSON string. To solve this problem, the ",(0,n.jsx)(t.code,{children:"from_xarray"})," function will convert and compress the data to a zarr array upload the data to object store, and only store the url to the object store in the database. This way we can store large amounts of data without having to worry about the database."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The call to the API now will create the image in the database and associate the url to the object store with the image. All additional information about the image will be stored in the database. This includes the name, the dimensions, the size, the type and the metadata."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The API will now return the image object with all the information about the image. This object is a local representation of the image on the server. It contains all the information about the image."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The image object will have a ",(0,n.jsx)(t.code,{children:"data"})," attribute. This attribute will be a lazy array that will only be loaded from the object store when needed (using dask and zarr to minimize the amount of data that needs to be loaded from the object store). If you want to convert the data to an in memory numpy array, you can use the ",(0,n.jsx)(t.code,{children:"compute"})," method of the array. This will load the data from the object store and convert it to a numpy array."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["It is important to understand that changing any attributes on the local instance of the image object will not change the image on the server. If you want to change the image on the server, you will have to expliclity call a mutation on the server. For example, if you want to change the name of the image, you will have to call the ",(0,n.jsx)(t.code,{children:"update_image"})," function on the server. And pass the new name as an argument. This will update the image on the server."]})})]})}function c(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>r});var n=a(67294);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);