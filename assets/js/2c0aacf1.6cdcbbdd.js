"use strict";(self.webpackChunkdoks=self.webpackChunkdoks||[]).push([[847],{3905:(e,t,o)=>{o.d(t,{Zo:()=>h,kt:()=>k});var a=o(67294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},r=Object.keys(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(o),p=n,k=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return o?a.createElement(k,i(i({ref:t},h),{},{components:o})):a.createElement(k,i({ref:t},h))}));function k(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=o.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<r;c++)i[c]=o[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}p.displayName="MDXCreateElement"},44944:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=o(87462),n=(o(67294),o(3905));const r={id:"arkitektrpc",title:"How do we call your app.",sidebar_label:"Calling your App",sidebar_position:1},i="How do we call your app.",s={unversionedId:"design/arkitektrpc",id:"design/arkitektrpc",title:"How do we call your app.",description:"Arkitekt is a platform that enables you to connect your favourite tools together. To do this, Arkitekt needs to know how to call your app. Arkitekt uses a simple protocol called Arkitekt RPC to call your app. Arkitekt RPC is a simple but powerful protocol that allows Arkitekt to call your app, and for your app to call Arkitekt. Arkitekt RPC is very much alike other RPC protocols, but extends their concepts to allow for a more client-side oriented approach.",source:"@site/docs/design/arkitekt-rpc.md",sourceDirName:"design",slug:"/design/arkitektrpc",permalink:"/doks/docs/design/arkitektrpc",draft:!1,editUrl:"https://github.com/jhnnsrs/doks/edit/master/docs/design/arkitekt-rpc.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"arkitektrpc",title:"How do we call your app.",sidebar_label:"Calling your App",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Design",permalink:"/doks/docs/category/design"},next:{title:"Middleman",permalink:"/doks/docs/design/middleman"}},l={},c=[{value:"What is an RPC protocol?",id:"what-is-an-rpc-protocol",level:2},{value:"The landscape of RPC protocols",id:"the-landscape-of-rpc-protocols",level:3},{value:"Advantages of the &#39;client-server&#39; RPC",id:"advantages-of-the-client-server-rpc",level:2},{value:"Easy to understand",id:"easy-to-understand",level:3},{value:"Fast to setup",id:"fast-to-setup",level:3},{value:"Easy to scale",id:"easy-to-scale",level:3},{value:"Easy to advertise functionality",id:"easy-to-advertise-functionality",level:3},{value:"Disadvantages of the &#39;client-server&#39; RPC in the Arkitekt context",id:"disadvantages-of-the-client-server-rpc-in-the-arkitekt-context",level:2},{value:"Not always suitable for a distributed environment.",id:"not-always-suitable-for-a-distributed-environment",level:3},{value:"Not easy to scale",id:"not-easy-to-scale",level:3},{value:"Not easy to debug",id:"not-easy-to-debug",level:3},{value:"Hard to protect",id:"hard-to-protect",level:3},{value:"Advantages of the &#39;message-based&#39;/&#39;broker&#39; RPC",id:"advantages-of-the-message-basedbroker-rpc",level:2},{value:"Easy to configure",id:"easy-to-configure",level:3},{value:"Easy to debug",id:"easy-to-debug",level:3},{value:"Easy to protect",id:"easy-to-protect",level:3},{value:"Easy to scale to and recover",id:"easy-to-scale-to-and-recover",level:3},{value:"The disadavantages of the message-based broker",id:"the-disadavantages-of-the-message-based-broker",level:2},{value:"Centralized broker",id:"centralized-broker",level:3},{value:"Latency",id:"latency",level:3},{value:"Hard to advertise functionality",id:"hard-to-advertise-functionality",level:3},{value:"Hard to setup",id:"hard-to-setup",level:3}],h={toc:c},d="wrapper";function u(e){let{components:t,...o}=e;return(0,n.kt)(d,(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"how-do-we-call-your-app"},"How do we call your app."),(0,n.kt)("p",null,"Arkitekt is a platform that enables you to connect your favourite tools together. To do this, Arkitekt needs to know how to call your app. Arkitekt uses a simple protocol called Arkitekt RPC to call your app. Arkitekt RPC is a simple but powerful protocol that allows Arkitekt to call your app, and for your app to call Arkitekt. Arkitekt RPC is very much alike other RPC protocols, but extends their concepts to allow for a more client-side oriented approach."),(0,n.kt)("h2",{id:"what-is-an-rpc-protocol"},"What is an RPC protocol?"),(0,n.kt)("p",null,"RPC stands for Remote Procedure Call. It is a protocol that allows one program to call a function in another program. The program that calls the function is called the client, and the program that implements the function is often called the server. The function that is called is called a procedure. The client and server communicate over a transport. Often the transport is a network connection, but it can also be a file, a pipe, or even a socket."),(0,n.kt)("p",null,"As the configuration of the specific RPC setup can vary quite dramatically (mutiple servers, data-streaming, etc), a variety of RPC protocols have been developed. All of them excel at different things, and all of them have their own quirks. Arkitekt RPC is a simple RPC protocol that is designed to solve the specific usecase that we encounter when we want to distribute our analysis on multiple bioimage analysis tools, and is by now means a replacement for other great RPC protocols (like gRPC, TRPC, etc)."),(0,n.kt)("h1",{id:"what-made-use-choose-to-develop-arkitekt-rpc"},"What made use choose to develop Arkitekt RPC?"),(0,n.kt)("p",null,"There are a lot of RPC protocols out there. Some of them are very mature, and have been around for a long time. Some of them are very new, and are still in development. Some of them are very simple, and some of them are very complex. We try to give you a good overview of our journey through the landscape of RPC protocols, and the problems that we encountered when we tried to use them. Arkitekts RPC is not a one-of-a-kind protocol. And parts of it functionality can be found in other protocols. So why did we choose to develop our own RPC protocol? Lets explore some of the reasons why we chose to develop our own RPC protocol, looking at the problems we encountered when we tried to use other RPC protocols."),(0,n.kt)("h3",{id:"the-landscape-of-rpc-protocols"},"The landscape of RPC protocols"),(0,n.kt)("p",null,"We will first devide them into two categories: 'client-server' RPC and 'message-based'' RPC (explaination of the two categories below). And briefly explain the advantages and disadvantages of each category."),(0,n.kt)("h1",{id:"the-client-server-rpc"},"The 'client-server' RPC"),(0,n.kt)("p",null,"~ Figure of client-server RPC ~"),(0,n.kt)("p",null,"In a client-server RPC the application that exposes its functionality, provides the infrastructure to call the functions. This means that the server needs to setup a transport, that the client can connect to. The client then calls the functions on the server returning the results. Great examples of this are the ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/XML-RPC"},"XML-RPC")," and ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/JSON-RPC"},"JSON-RPC")," protocols, as well as the ",(0,n.kt)("a",{parentName:"p",href:"https://grpc.io/"},"gRPC")," protocol."),(0,n.kt)("h2",{id:"advantages-of-the-client-server-rpc"},"Advantages of the 'client-server' RPC"),(0,n.kt)("h3",{id:"easy-to-understand"},"Easy to understand"),(0,n.kt)("p",null,"Very easy to understand setup, with distinct client and server roles and responsibilities."),(0,n.kt)("h3",{id:"fast-to-setup"},"Fast to setup"),(0,n.kt)("p",null,"Very easy to setup, as the server just needs to expose the functions, and the client just needs to call the functions."),(0,n.kt)("h3",{id:"easy-to-scale"},"Easy to scale"),(0,n.kt)("p",null,"When done right, the server can be scaled by just spinning up more servers. The client does not need to know about the servers, if you are using a load balancer, the client will just connect to the load balancer, and the load balancer will distribute the requests to the servers."),(0,n.kt)("h3",{id:"easy-to-advertise-functionality"},"Easy to advertise functionality"),(0,n.kt)("p",null,"The server can advertise its functionality by just exposing an endpoint that returns the list of functions that it exposes. The client can then inspect\nthis list and call the functions that it needs."),(0,n.kt)("h2",{id:"disadvantages-of-the-client-server-rpc-in-the-arkitekt-context"},"Disadvantages of the 'client-server' RPC in the Arkitekt context"),(0,n.kt)("h3",{id:"not-always-suitable-for-a-distributed-environment"},"Not always suitable for a distributed environment."),(0,n.kt)("p",null,"The problem with this approach though that it is very hard to make it work in the distributed environment, that we envisioned with arkitekt. In a distributed environment, the client and server are not always on the same machine and importantly may not know where they are located in respect to each other (Discovery problem)."),(0,n.kt)("p",null,"~ Figure of client-server RPC falling short when in another network~"),(0,n.kt)("p",null,"You can fix this by using a service discovery protocol, but this adds a lot of complexity to the setup. And it is not always possible to use a service discovery protocol. For example, if your application with exposed functionatliy sits behind a institutional firewall, you may not be able to connect to it from outside the firewall, as the firewall may not allow incoming connections."),(0,n.kt)("h3",{id:"not-easy-to-scale"},"Not easy to scale"),(0,n.kt)("p",null,"When done right, the server can be scaled by just spinning up more servers. The client does not need to know about the servers, if you are using a load balancer, the client will just connect to the load balancer, and the load balancer will distribute the requests to the servers. Setting up a load balancer however is not a trivial task and automatic configuration again necesitates a service discovery protocol."),(0,n.kt)("p",null,"~ Figure of load balancer ~"),(0,n.kt)("h3",{id:"not-easy-to-debug"},"Not easy to debug"),(0,n.kt)("p",null,"Because computers are not perfect, things can go wrong. When things go wrong, it is very hard to debug the problem. The client does not know what is going on on the server, or even if the server is still running. The server does not know if the client is still running, or if the client is still connected. This makes it very hard to debug problems, especially if we want to enable workflows that are distributed over multiple machines. "),(0,n.kt)("p",null,"~ Figure of client-server RPC falling short when an error occurs in one app ~"),(0,n.kt)("p",null,"Here we see that the client is still running, but the server is not. The client does not know this, and will keep on sending requests to the server, which will never be answered. But how does the client know that the server is not running? It does not. It just keeps on sending requests, and the requests will just time out. This makes it very hard to debug problems, especially if we want to enable workflows that are distributed over multiple machines."),(0,n.kt)("h3",{id:"hard-to-protect"},"Hard to protect"),(0,n.kt)("p",null,"One of the core ideas behind arkitekt was that we wanted to develop a secure platform. This means that we want to make sure that the functionatliy is not being used by a malicious actor. This is very hard to do in a client-server RPC setup, as the server needs to implement its own security policy to protect itself from malicious actors. This is not a trivial task, and is very hard to get right."),(0,n.kt)("h1",{id:"the-message-basedbroker-rpc"},"The 'message-based'/'broker' RPC"),(0,n.kt)("p",null,"~ Figure of broker RPC ~"),(0,n.kt)("p",null,"In a message-based RPC, the application that exposes its functionality, does not provide the infrastructure to call the functions. Instead, the application that exposes its functionality, connects as a client (worker) to a central server (a broker). The calling agent then again as a client connects to the broker demanding to call a specific funtionality and the broker then routes the request to the worker. The worker then executes the function and returns the result to the broker, which then returns the result to the calling agent."),(0,n.kt)("h2",{id:"advantages-of-the-message-basedbroker-rpc"},"Advantages of the 'message-based'/'broker' RPC"),(0,n.kt)("h3",{id:"easy-to-configure"},"Easy to configure"),(0,n.kt)("p",null,"As the broker is a central server that all the clients connect to, it is very easy to configure. As long as the broker can be configured to accept connections from all the clients, all clients are in theory able to talk to each other through the broker. This compleltely removes the need for a service discovery protocol (as long as we know where the broker is)"),(0,n.kt)("h3",{id:"easy-to-debug"},"Easy to debug"),(0,n.kt)("p",null,"The broker is a central point of authority. It knows what workers are available, and it knows what workers are busy. This makes it very easy to debug problems, as the broker can tell you what is going on. "),(0,n.kt)("h3",{id:"easy-to-protect"},"Easy to protect"),(0,n.kt)("p",null,"The broker can implement its own security policy to protect itself from malicious actors. This again is not a trivial task, and is very hard to get right. But once it is done, it is done. All the workers are protected by the security policy of the broker, and we can have a central source of truth for the security policy of each worker (app)"),(0,n.kt)("h3",{id:"easy-to-scale-to-and-recover"},"Easy to scale to and recover"),(0,n.kt)("p",null,"~ Message based broker with multiple workers (Topic) ~"),(0,n.kt)("p",null,"It also makes it very easy to scale the system, as you can just spin up more workers to handle the load of all the requests that are coming in. As we are just sending messages to the broker, and the broker is then routing the messages to the workers, we can scale the system by just spinning up more workers, without any additional configuration. Conceptually this is very similar to the load balancer in the client-server RPC, however often queues are introduced to enable the broker to route the requests to the workers that are not busy."),(0,n.kt)("p",null,"Additionality if a worker goes down, the broker will just (re)route the requests to another worker, and the calling agent will not even notice that the worker went down. Often the broker will also keep track of the state of the workers, so that it can route the requests to the workers that are not busy."),(0,n.kt)("h2",{id:"the-disadavantages-of-the-message-based-broker"},"The disadavantages of the message-based broker"),(0,n.kt)("h3",{id:"centralized-broker"},"Centralized broker"),(0,n.kt)("p",null,"The broker is a central point of failure. If the broker goes down, all the workers are not able to do their work. This can make it very hard to scale the system, as you need to make sure that the broker can handle the load of all the requests that are coming in. (We can however use a truly distributed broker like Kafka, but this is not trivial to setup and maintain.)"),(0,n.kt)("h3",{id:"latency"},"Latency"),(0,n.kt)("p",null,"As all connections have to be routed through the broker, there is a latency penalty. This is not always a big problem, as the latency penalty is very small, but it is still quite a penalty if your application is latency sensitive, and could have connected directly to the worker."),(0,n.kt)("h3",{id:"hard-to-advertise-functionality"},"Hard to advertise functionality"),(0,n.kt)("p",null,"As the broker is just made to route messages, it does not know what functionality is available on the workers. This means that the workers need to advertise their functionality to a central repository of all functionality that is available. This necessates a common protocol often interface definition language (IDL) to be used by all workers."),(0,n.kt)("h3",{id:"hard-to-setup"},"Hard to setup"),(0,n.kt)("p",null,"The initial setup of the broker is not trivial, as you need to be familiar with the technology."),(0,n.kt)("h1",{id:"the-decision-on-the-architecture"},"The decision on the architecture"),(0,n.kt)("p",null,"It was not an easy decision to make, but we decided to go with the message-based RPC protocol. We believe that the advantages of the message-based RPC protocol outweigh the disadvantages (in our specific use case). Arkitekt is a platform that wants to focus on the functionality of the applicationn, and provide a secure and easy to use platform. We believe that the message-based RPC protocol is the best fit for this use case. But lets look at our design in more detail."),(0,n.kt)("p",null,"~ Image of discovry protocol, side by side with assignment protocol ~"),(0,n.kt)("p",null,"In our design the arkitekt platform (indeed its ",(0,n.kt)("inlineCode",{parentName:"p"},"rekuest")," service) is the central broker, that negotiates between your applications. As discussed previously, we need a central repository for our functionality, that all applications can publish to and read from. With ",(0,n.kt)("inlineCode",{parentName:"p"},"rekuest")," we also provide this and enable apps to simply publish their functionality when connecting to the platform. This functionality is then available to all other apps that are connected to the platform in the form of a Template implementing a Node. See the ",(0,n.kt)("a",{parentName:"p",href:"/doks/docs/design/terminology/template"},"Template")," section for more information on this. The application now when put into\nthe provide mode, will connect to the central broker as an agent (worker). This agent is now uniquely identified by the user, and the oauth2 client as well as an instance_id (If you would like to use multiple instances of the same application). The agent now represents a stateful connection to the broker, and we can track the state of all of the agents on the platform."),(0,n.kt)("p",null,"Importantly the agent does not listen to any requests by itself, but will only do so when receiving a provision. (see figure2). A provision is the act of requesting a specific functionality of an applicaiton through the broker. It represents a contract between the application and the broker. The application can choose to respect this contract, or not (e.g when it can't ensure the requested resources are available). "),(0,n.kt)("p",null,"Clients trying to use the functionality of an application, will connect to the broker, and request a reservation. A reservation is a request to the broker to make a specific functionality available for the client. Again its a contract between the broker and this time the client. The broker will then try to find an application that provided the functioniality (already exisiting provision) or provide this functionality (creating a provision) on another app. This provision is then linked to the reservation. "),(0,n.kt)("p",null,"When now requesting to use the functionality (doing the RPC call itself), the client will send a request through its connection to the reservation which will in turn map this request to the provision. The provision will then send the request to the agent, which will then execute the request and return the result to the provision, which will then return the result to the reservation, which will then return the result to the client. "),(0,n.kt)("p",null,"We establish these contracts as core elements of our design as they allow a clear seperation between the client and the worker. Additionaly these contracts\nallow the client to determine the conditions of validity of its contract to use the functionality (e.g demanding multiple workers to be available, which apps\nare allowed to provide the functionality, etc). This enables easy debugging of the system, as the broker can tell you what is going on."),(0,n.kt)("p",null,"Internally these contracts mimic closely the concepts of topics and queues in message-based systems. The reservation is the topic, and the provisions are the queues that are subscribed (in a round-robin manner) to the topic. The client send messages to the topic and they get mapped to the queue."),(0,n.kt)("p",null,"~ Extended image of the broker RPC with arkitekts, reservation and provision ~"),(0,n.kt)("p",null,"Lets look at the image above. We see that the broker is still the central point of authority, and both the application providing functionality and the client are connecting to it, through stateful connections. However we introduce the concept of reservations and provisions"),(0,n.kt)("h1",{id:"going-asynchronous"},"Going asynchronous"),(0,n.kt)("p",null,"One of the most important decisions when choosing to use an RPC protocol is choosing how you want to interface with your application. Do you want to use synchronous or asynchronous calls?"),(0,n.kt)("p",null,"Synchronous RPC calls are blocking. The client will wait for the server to return the result before it can continue. Asynchronous RPC calls are non-blocking. The client will not wait for the server to return the result before it can continue. "),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Notice, that this behaviour is completely orthogonal to the design of the protocol. It possible to use synchronous or asynchronous calls both in a message-based RPC protocol and in a client-server protocol. In a message-based RPC protocol, the client can send a request to the broker, and then wait for the broker to return the result. Or the client can send a request to the broker, and then continue with its work. The broker will then send the result to the client when it is ready.")),(0,n.kt)("p",null,"Even though we provide you with synchronous interface in our client-libraries, arkitekt is designed to be asynchronous, which allows you to easily design\nconcurrent workflows, "),(0,n.kt)("h1",{id:"the-requestresponse-cycle"},"The request/response cycle"),(0,n.kt)("h1",{id:"the-message-based-rpc"},"The message-based RPC"),(0,n.kt)("h1",{id:"the-client-focus-rpc"},"The 'client-focus' RPC"))}u.isMDXComponent=!0}}]);