(self.webpackChunkdoks=self.webpackChunkdoks||[]).push([[4404],{47598:(e,t,s)=>{e.exports={src:{srcSet:s.p+"assets/ideal-img/batch-stream.e0b0917.640.png 640w,"+s.p+"assets/ideal-img/batch-stream.4b78ead.1275.png 1275w",images:[{path:s.p+"assets/ideal-img/batch-stream.e0b0917.640.png",width:640,height:383},{path:s.p+"assets/ideal-img/batch-stream.4b78ead.1275.png",width:1275,height:763}],src:s.p+"assets/ideal-img/batch-stream.e0b0917.640.png",toString:function(){return s.p+"assets/ideal-img/batch-stream.e0b0917.640.png"},placeholder:void 0,width:640,height:383},preSrc:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9UlEQVR4nGO4efOm9M3r19N3/v/P/T8/J+B/QUWsy/96KY/X2WluHwqFGBgYGP7//8/EcOXKFYOP79//v/bhQ85fV5f2/wFhP/u2pPt7/C/57/chv/r///9sV/4/AmtguHb5ss/le/f0P0VGinxLTo76n1khGPaqxiv6UYUpSH7VqlXMYGP////P8///f5Z/+/fL/P/yRfLW///s9f8m8q36/58ZbBIIvHz5UuLGtWsfz/z/7/bf07P/f2DYTqH/vdKurzI+Fb/t9gQr+s/ACDKR4+rVq+bX/v8X/lFaqvqzqt6o/v8mroSX9VazP6yCuI2BgQEACgWAYlwGR2QAAAAASUVORK5CYII="}},81401:(e,t,s)=>{"use strict";s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>h,default:()=>p,frontMatter:()=>l,metadata:()=>c,toc:()=>m});var o=s(85893),n=s(11151),a=s(15944),i=s(47598),r=s.n(i);const l={title:"Arkitekt vs Nextflow",sidebar_label:"...Nextflow.",sidebar_position:1},h=void 0,c={id:"design/vs/nextflow",title:"Arkitekt vs Nextflow",description:"Arkitekt vs Nextflow",source:"@site/docs/design/vs/nextflow.mdx",sourceDirName:"design/vs",slug:"/design/vs/nextflow",permalink:"/docs/design/vs/nextflow",draft:!1,unlisted:!1,editUrl:"https://github.com/jhnnsrs/doks/edit/master/docs/design/vs/nextflow.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Arkitekt vs Nextflow",sidebar_label:"...Nextflow.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Arkitekt Vs. ...",permalink:"/docs/category/arkitekt-vs-"},next:{title:"Intro",permalink:"/docs/design/vs/intro"}},d={},m=[{value:"Arkitekt vs Nextflow",id:"arkitekt-vs-nextflow",level:2},{value:"Conceptual differences",id:"conceptual-differences",level:3},{value:"Graphical Workflows vs Nextflow DSL",id:"graphical-workflows-vs-nextflow-dsl",level:3},{value:"Execution model",id:"execution-model",level:4},{value:"Arkitekt Streams vs Nextflow Channels",id:"arkitekt-streams-vs-nextflow-channels",level:3},{value:"Nextflow",id:"nextflow",level:4}];function f(e){const t={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"arkitekt-vs-nextflow",children:"Arkitekt vs Nextflow"}),"\n",(0,o.jsx)(t.p,{children:"Nextflow and Arkitekt are very similar tools, and they share a lot of the same concepts. However, there are some key differences between the two tools that are worth noting."}),"\n",(0,o.jsx)(t.h3,{id:"conceptual-differences",children:"Conceptual differences"}),"\n",(0,o.jsx)(t.p,{children:"Arkitekt and Nextflow, both try to solve a similar problem. How to create a workflow that uses tasks that run on a variety of different hardware,and how to wire data from a\ntask to another task, to make your work reproducible. However, the two tools have different approaches to solving this problem, and excell in their own niche."}),"\n",(0,o.jsx)(t.h3,{id:"graphical-workflows-vs-nextflow-dsl",children:"Graphical Workflows vs Nextflow DSL"}),"\n",(0,o.jsx)(t.p,{children:"One of the most obvious differences between Arkitekt and Nextflow is that Arkitekt uses a graphical interface to create workflows, while Nextflow uses a Domain Specific Language\nthat is written in a text editor. This is a very important difference, and it is worth noting that both approaches have their own advantages and disadvantages. Importantly this has\nnot only implications for the user experience, but also for the way that the workflow is executed. Some concepts of Arkitekt are not easily translated to Nextflow, and vice versa."}),"\n",(0,o.jsx)(t.h4,{id:"execution-model",children:"Execution model"}),"\n",(0,o.jsx)(t.p,{children:"Nextflow is based on the idea of stateless tasks that are executed in a shell. This means that the tasks are executed in a shell, and once the process is finished, the state is lost.\nThis is very different from Arkitekt, where all apps can maintain their state, and are only  able to communicate with other apps through messages (Actor based programming). This has some important implications\nfor the way that a workflow is executed. Let's look at this example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-groovy",children:'params.images = "./images/*.tif" // Images to load\n\n// Input channel for images\nChannel\n    .fromPath(params.images)\n    .into { imagesChannel }\n\n// Process 1: Run StarDist on each image\nprocess RunStarDist {\n    input:\n    file image from imagesChannel\n\n    output:\n    file "segmented_${image.baseName}.tif" into stardistChannel\n\n    script:\n    """\n    # Replace with your StarDist command\n    stardist segment ${image} -o segmented_${image.baseName}.tif\n    """\n}\n\n// Process 2: Calculate Maximum or further processing\nprocess CalculateMaximum {\n    input:\n    file segmentedImage from stardistChannel.collect()\n\n    output:\n    file "max_values.txt"\n\n    script:\n    """\n    # Replace with your script/command to calculate the maximum or further process\n    your_analysis_tool ${segmentedImage} > max_values.txt\n    """\n}\n\n// Workflow definition using pipe operator\nworkflow {\n    imagesChannel | RunStarDist | CalculateMaximum\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"This is a simple Nextflow workflow that runs StarDist on a set of images, and then calculates the maximum of the segmented images. The workflow is defined using the pipe operator,\nwhich allows you to connect the output of one task to the input of another task. This is very similar to the way that\nArkitekt connects apps using streams. However there are some important differences about the execution and performance implications of this workflow."}),"\n",(0,o.jsxs)(t.p,{children:["In this workflow, the images are loaded into a channel and then passed to the ",(0,o.jsx)(t.code,{children:"RunStarDist"})," ",(0,o.jsx)(t.code,{children:"process"}),". Here the terminology is a bit confusing, as the ",(0,o.jsx)(t.code,{children:"process"})," is actually a task\nthat will spawn ",(0,o.jsx)(t.em,{children:"multiple os-level processes"}),' in your command line. This means that stardist will actually start executing, load the model into the GPU, and then segment the image. Once the\nsegmentation is finished, the process will exit, and the state is lost. The output will be passed to the next task, which will process its queue of images autonomously and in "parallel".']}),"\n",(0,o.jsxs)(t.p,{children:["This is very different from the way that Arkitekt executes workflows. In Arkitekt, the apps are stateful, and can maintain their state. This means that the ",(0,o.jsx)(t.code,{children:"RunStarDist"})," node in our workflow\n(see below) can maintain its state, and will not have to exit after processing one image. This means that the model will only be loaded once, and then the images will be processed one after\nanother, in the ",(0,o.jsx)(t.em,{children:"same os-level process"}),". This has some important implications for the performance of the workflow, as the whole workflow will be executed in a ",(0,o.jsx)(t.strong,{children:"single process"}),", and setup time\nwill be minimized."]}),"\n",(0,o.jsx)(t.p,{children:'This gain in performance for the becomes more pronounced when setting up the per process environment is more expensive. For example, if you are running a workflow on a cluster, and you have to\nuse docker containers to execute your command, the setup time for each process will be much higher (as now also the "docker run" command needs to spin up and down the container).'}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsx)(t.p,{children:'It is important to note that Arkitekts ability to be "statefull" is not a magic bullet, but a double edged sword, with its own set of problems. For example, if you have a memory leak in your\napplication, the memory will not be freed after processing one image, and the memory usage will increase over time. This is not a problem in Nextflow, as the process will exit after processing\none image, and the memory will be freed.'})}),"\n",(0,o.jsx)(t.p,{children:"This core difference in the execution model of the two tools, has some important implications for the way that workflows are designed. For example, in Nextflow it is very common to use\nfor big batch jobs, where you want to process a large number of images, and start up time is not a problem. In Arkitekt, it is more common to use workflows where you want to process single\nfast arriving messages and you want to minimze your time to feedback (as it might be important to get the results of your workflow as fast as possible, e.g in a smart microscopy setting)."}),"\n",(0,o.jsxs)("div",{className:"mt-2 w-20",children:[(0,o.jsx)(a.Z,{img:r()}),(0,o.jsx)("div",{className:"text-gray-400 mb-2",children:(0,o.jsx)("small",{children:" The time to feedback (results of a single time of your worklfow) "})})]}),"\n",(0,o.jsxs)(t.p,{children:["Of course you can easily ",(0,o.jsx)(t.em,{children:"emulate"})," the execution model of Nextflow in Arkitekt by making your apps run a command in the shell, and then exit."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"It is important to note that this is not a hard rule, and you can use both tools for both use cases. However, the tools are optimized for different use cases.\nWe are however working on implementing a next-flow like execution model in Arkitekt, that will allow you to run workflows in a similar way as Nextflow, if you\nprefer the entirely stateless execution model."})}),"\n",(0,o.jsx)(t.h3,{id:"arkitekt-streams-vs-nextflow-channels",children:"Arkitekt Streams vs Nextflow Channels"}),"\n",(0,o.jsx)(t.p,{children:"On first glance, Arkitekt streams and Nextflow channels are very similar. They both represent a stream of data that can be passed from one task to another, and the connections\nof data forms the conceptual workflow. However, there are some key differences between the two, that are worth noting."}),"\n",(0,o.jsx)(t.h4,{id:""}),"\n",(0,o.jsx)(t.h4,{id:"nextflow",children:"Nextflow"}),"\n",(0,o.jsx)(t.p,{children:'Nextflow is a tool that is fabolous for reliably running workflows in a variety of different settings, but excels at running workflows on a cluster of machines. An important\nfeature of Nextflow is that it heavily borrows from the UNIX philosophy of "pipelines" and "streams", and you can easily pipe data from one task to another. In this regard\nNextflow is very much similar to Arkitekt, that also borrows from this idea of streams.'})]})}function p(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}}}]);