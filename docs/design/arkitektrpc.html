<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-design/arkitektrpc">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">How do we call your app. | Arkitekt</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://arkitekt.live/doks/img/favicon.svg"><meta data-rh="true" name="twitter:image" content="https://arkitekt.live/doks/img/favicon.svg"><meta data-rh="true" property="og:url" content="https://arkitekt.live/doks/docs/design/arkitektrpc"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="How do we call your app. | Arkitekt"><meta data-rh="true" name="description" content="Arkitekt is a platform that enables you to connect your favourite tools together. To do this, Arkitekt needs to know how to call your app. Arkitekt uses a simple protocol called Arkitekt RPC to call your app. Arkitekt RPC is a simple but powerful protocol that allows Arkitekt to call your app, and for your app to call Arkitekt. Arkitekt RPC is very much alike other RPC protocols, but extends their concepts to allow for a more client-side oriented approach."><meta data-rh="true" property="og:description" content="Arkitekt is a platform that enables you to connect your favourite tools together. To do this, Arkitekt needs to know how to call your app. Arkitekt uses a simple protocol called Arkitekt RPC to call your app. Arkitekt RPC is a simple but powerful protocol that allows Arkitekt to call your app, and for your app to call Arkitekt. Arkitekt RPC is very much alike other RPC protocols, but extends their concepts to allow for a more client-side oriented approach."><link data-rh="true" rel="icon" href="/doks/img/favicon.svg"><link data-rh="true" rel="canonical" href="https://arkitekt.live/doks/docs/design/arkitektrpc"><link data-rh="true" rel="alternate" href="https://arkitekt.live/doks/docs/design/arkitektrpc" hreflang="en"><link data-rh="true" rel="alternate" href="https://arkitekt.live/doks/docs/design/arkitektrpc" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/doks/blog/rss.xml" title="Arkitekt RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doks/blog/atom.xml" title="Arkitekt Atom Feed"><link rel="stylesheet" href="/doks/assets/css/styles.fecd0f84.css">
<link rel="preload" href="/doks/assets/js/runtime~main.909a4a31.js" as="script">
<link rel="preload" href="/doks/assets/js/main.f18b54af.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
 <!-- --> <!-- --> <!-- --> <div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doks/"><div class="navbar__logo"><img src="/doks/img/favicon.svg" alt="Doks Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/doks/img/favicon.svg" alt="Doks Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">arkitekt</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doks/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doks/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jhnnsrs/doks" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div class="my-auto" data-headlessui-state=""><div><button class="inline-flex border-0 cursor-pointer bg-primary-300 w-full justify-center rounded-md text-white px-4 py-2 my-auto shadow-primary-300/20 hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75" type="button" aria-expanded="false" data-headlessui-state="">Connect</button></div></div><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doks/docs/intro">Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/doks/docs/category/introduction">Introduction</a><button aria-label="Toggle the collapsible sidebar category &#x27;Introduction&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/doks/docs/category/services">Services</a><button aria-label="Toggle the collapsible sidebar category &#x27;Services&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/doks/docs/category/design">Design</a><button aria-label="Toggle the collapsible sidebar category &#x27;Design&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doks/docs/design/arkitektrpc">Calling your App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doks/docs/design/middleman">Middleman</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doks/docs/design/real-time">Real-time</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/doks/docs/category/security">Security</a><button aria-label="Toggle the collapsible sidebar category &#x27;Security&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/doks/docs/category/terminology">Terminology</a><button aria-label="Toggle the collapsible sidebar category &#x27;Terminology&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/doks/docs/category/for-developers">For Developers</a><button aria-label="Toggle the collapsible sidebar category &#x27;For Developers&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/doks/docs/category/repo">Repo</a><button aria-label="Toggle the collapsible sidebar category &#x27;Repo&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/doks/docs/category/features">Features</a><button aria-label="Toggle the collapsible sidebar category &#x27;Features&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/doks/docs/examples/interactive_workflow">examples</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doks/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/doks/docs/category/design"><span itemprop="name">Design</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Calling your App</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>How do we call your app.</h1><p>Arkitekt is a platform that enables you to connect your favourite tools together. To do this, Arkitekt needs to know how to call your app. Arkitekt uses a simple protocol called Arkitekt RPC to call your app. Arkitekt RPC is a simple but powerful protocol that allows Arkitekt to call your app, and for your app to call Arkitekt. Arkitekt RPC is very much alike other RPC protocols, but extends their concepts to allow for a more client-side oriented approach.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-is-an-rpc-protocol">What is an RPC protocol?<a href="#what-is-an-rpc-protocol" class="hash-link" aria-label="Direct link to What is an RPC protocol?" title="Direct link to What is an RPC protocol?">​</a></h2><p>RPC stands for Remote Procedure Call. It is a protocol that allows one program to call a function in another program. The program that calls the function is called the client, and the program that implements the function is often called the server. The function that is called is called a procedure. The client and server communicate over a transport. Often the transport is a network connection, but it can also be a file, a pipe, or even a socket.</p><p>As the configuration of the specific RPC setup can vary quite dramatically (mutiple servers, data-streaming, etc), a variety of RPC protocols have been developed. All of them excel at different things, and all of them have their own quirks. Arkitekt RPC is a simple RPC protocol that is designed to solve the specific usecase that we encounter when we want to distribute our analysis on multiple bioimage analysis tools, and is by now means a replacement for other great RPC protocols (like gRPC, TRPC, etc).</p><h1>What made use choose to develop Arkitekt RPC?</h1><p>There are a lot of RPC protocols out there. Some of them are very mature, and have been around for a long time. Some of them are very new, and are still in development. Some of them are very simple, and some of them are very complex. We try to give you a good overview of our journey through the landscape of RPC protocols, and the problems that we encountered when we tried to use them. Arkitekts RPC is not a one-of-a-kind protocol. And parts of it functionality can be found in other protocols. So why did we choose to develop our own RPC protocol? Lets explore some of the reasons why we chose to develop our own RPC protocol, looking at the problems we encountered when we tried to use other RPC protocols.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-landscape-of-rpc-protocols">The landscape of RPC protocols<a href="#the-landscape-of-rpc-protocols" class="hash-link" aria-label="Direct link to The landscape of RPC protocols" title="Direct link to The landscape of RPC protocols">​</a></h3><p>We will first devide them into two categories: &#x27;client-server&#x27; RPC and &#x27;message-based&#x27;&#x27; RPC (explaination of the two categories below). And briefly explain the advantages and disadvantages of each category.</p><h1>The &#x27;client-server&#x27; RPC</h1><p>~ Figure of client-server RPC ~</p><p>In a client-server RPC the application that exposes its functionality, provides the infrastructure to call the functions. This means that the server needs to setup a transport, that the client can connect to. The client then calls the functions on the server returning the results. Great examples of this are the <a href="https://en.wikipedia.org/wiki/XML-RPC" target="_blank" rel="noopener noreferrer">XML-RPC</a> and <a href="https://en.wikipedia.org/wiki/JSON-RPC" target="_blank" rel="noopener noreferrer">JSON-RPC</a> protocols, as well as the <a href="https://grpc.io/" target="_blank" rel="noopener noreferrer">gRPC</a> protocol.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-of-the-client-server-rpc">Advantages of the &#x27;client-server&#x27; RPC<a href="#advantages-of-the-client-server-rpc" class="hash-link" aria-label="Direct link to Advantages of the &#x27;client-server&#x27; RPC" title="Direct link to Advantages of the &#x27;client-server&#x27; RPC">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-understand">Easy to understand<a href="#easy-to-understand" class="hash-link" aria-label="Direct link to Easy to understand" title="Direct link to Easy to understand">​</a></h3><p>Very easy to understand setup, with distinct client and server roles and responsibilities.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fast-to-setup">Fast to setup<a href="#fast-to-setup" class="hash-link" aria-label="Direct link to Fast to setup" title="Direct link to Fast to setup">​</a></h3><p>Very easy to setup, as the server just needs to expose the functions, and the client just needs to call the functions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-scale">Easy to scale<a href="#easy-to-scale" class="hash-link" aria-label="Direct link to Easy to scale" title="Direct link to Easy to scale">​</a></h3><p>When done right, the server can be scaled by just spinning up more servers. The client does not need to know about the servers, if you are using a load balancer, the client will just connect to the load balancer, and the load balancer will distribute the requests to the servers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-advertise-functionality">Easy to advertise functionality<a href="#easy-to-advertise-functionality" class="hash-link" aria-label="Direct link to Easy to advertise functionality" title="Direct link to Easy to advertise functionality">​</a></h3><p>The server can advertise its functionality by just exposing an endpoint that returns the list of functions that it exposes. The client can then inspect
this list and call the functions that it needs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="disadvantages-of-the-client-server-rpc-in-the-arkitekt-context">Disadvantages of the &#x27;client-server&#x27; RPC in the Arkitekt context<a href="#disadvantages-of-the-client-server-rpc-in-the-arkitekt-context" class="hash-link" aria-label="Direct link to Disadvantages of the &#x27;client-server&#x27; RPC in the Arkitekt context" title="Direct link to Disadvantages of the &#x27;client-server&#x27; RPC in the Arkitekt context">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="not-always-suitable-for-a-distributed-environment">Not always suitable for a distributed environment.<a href="#not-always-suitable-for-a-distributed-environment" class="hash-link" aria-label="Direct link to Not always suitable for a distributed environment." title="Direct link to Not always suitable for a distributed environment.">​</a></h3><p>The problem with this approach though that it is very hard to make it work in the distributed environment, that we envisioned with arkitekt. In a distributed environment, the client and server are not always on the same machine and importantly may not know where they are located in respect to each other (Discovery problem).</p><p>~ Figure of client-server RPC falling short when in another network~</p><p>You can fix this by using a service discovery protocol, but this adds a lot of complexity to the setup. And it is not always possible to use a service discovery protocol. For example, if your application with exposed functionatliy sits behind a institutional firewall, you may not be able to connect to it from outside the firewall, as the firewall may not allow incoming connections.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="not-easy-to-scale">Not easy to scale<a href="#not-easy-to-scale" class="hash-link" aria-label="Direct link to Not easy to scale" title="Direct link to Not easy to scale">​</a></h3><p>When done right, the server can be scaled by just spinning up more servers. The client does not need to know about the servers, if you are using a load balancer, the client will just connect to the load balancer, and the load balancer will distribute the requests to the servers. Setting up a load balancer however is not a trivial task and automatic configuration again necesitates a service discovery protocol.</p><p>~ Figure of load balancer ~</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="not-easy-to-debug">Not easy to debug<a href="#not-easy-to-debug" class="hash-link" aria-label="Direct link to Not easy to debug" title="Direct link to Not easy to debug">​</a></h3><p>Because computers are not perfect, things can go wrong. When things go wrong, it is very hard to debug the problem. The client does not know what is going on on the server, or even if the server is still running. The server does not know if the client is still running, or if the client is still connected. This makes it very hard to debug problems, especially if we want to enable workflows that are distributed over multiple machines. </p><p>~ Figure of client-server RPC falling short when an error occurs in one app ~</p><p>Here we see that the client is still running, but the server is not. The client does not know this, and will keep on sending requests to the server, which will never be answered. But how does the client know that the server is not running? It does not. It just keeps on sending requests, and the requests will just time out. This makes it very hard to debug problems, especially if we want to enable workflows that are distributed over multiple machines.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hard-to-protect">Hard to protect<a href="#hard-to-protect" class="hash-link" aria-label="Direct link to Hard to protect" title="Direct link to Hard to protect">​</a></h3><p>One of the core ideas behind arkitekt was that we wanted to develop a secure platform. This means that we want to make sure that the functionatliy is not being used by a malicious actor. This is very hard to do in a client-server RPC setup, as the server needs to implement its own security policy to protect itself from malicious actors. This is not a trivial task, and is very hard to get right.</p><h1>The &#x27;message-based&#x27;/&#x27;broker&#x27; RPC</h1><p>~ Figure of broker RPC ~</p><p>In a message-based RPC, the application that exposes its functionality, does not provide the infrastructure to call the functions. Instead, the application that exposes its functionality, connects as a client (worker) to a central server (a broker). The calling agent then again as a client connects to the broker demanding to call a specific funtionality and the broker then routes the request to the worker. The worker then executes the function and returns the result to the broker, which then returns the result to the calling agent.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-of-the-message-basedbroker-rpc">Advantages of the &#x27;message-based&#x27;/&#x27;broker&#x27; RPC<a href="#advantages-of-the-message-basedbroker-rpc" class="hash-link" aria-label="Direct link to Advantages of the &#x27;message-based&#x27;/&#x27;broker&#x27; RPC" title="Direct link to Advantages of the &#x27;message-based&#x27;/&#x27;broker&#x27; RPC">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-configure">Easy to configure<a href="#easy-to-configure" class="hash-link" aria-label="Direct link to Easy to configure" title="Direct link to Easy to configure">​</a></h3><p>As the broker is a central server that all the clients connect to, it is very easy to configure. As long as the broker can be configured to accept connections from all the clients, all clients are in theory able to talk to each other through the broker. This compleltely removes the need for a service discovery protocol (as long as we know where the broker is)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-debug">Easy to debug<a href="#easy-to-debug" class="hash-link" aria-label="Direct link to Easy to debug" title="Direct link to Easy to debug">​</a></h3><p>The broker is a central point of authority. It knows what workers are available, and it knows what workers are busy. This makes it very easy to debug problems, as the broker can tell you what is going on. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-protect">Easy to protect<a href="#easy-to-protect" class="hash-link" aria-label="Direct link to Easy to protect" title="Direct link to Easy to protect">​</a></h3><p>The broker can implement its own security policy to protect itself from malicious actors. This again is not a trivial task, and is very hard to get right. But once it is done, it is done. All the workers are protected by the security policy of the broker, and we can have a central source of truth for the security policy of each worker (app)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="easy-to-scale-to-and-recover">Easy to scale to and recover<a href="#easy-to-scale-to-and-recover" class="hash-link" aria-label="Direct link to Easy to scale to and recover" title="Direct link to Easy to scale to and recover">​</a></h3><p>~ Message based broker with multiple workers (Topic) ~</p><p>It also makes it very easy to scale the system, as you can just spin up more workers to handle the load of all the requests that are coming in. As we are just sending messages to the broker, and the broker is then routing the messages to the workers, we can scale the system by just spinning up more workers, without any additional configuration. Conceptually this is very similar to the load balancer in the client-server RPC, however often queues are introduced to enable the broker to route the requests to the workers that are not busy.</p><p>Additionality if a worker goes down, the broker will just (re)route the requests to another worker, and the calling agent will not even notice that the worker went down. Often the broker will also keep track of the state of the workers, so that it can route the requests to the workers that are not busy.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-disadavantages-of-the-message-based-broker">The disadavantages of the message-based broker<a href="#the-disadavantages-of-the-message-based-broker" class="hash-link" aria-label="Direct link to The disadavantages of the message-based broker" title="Direct link to The disadavantages of the message-based broker">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="centralized-broker">Centralized broker<a href="#centralized-broker" class="hash-link" aria-label="Direct link to Centralized broker" title="Direct link to Centralized broker">​</a></h3><p>The broker is a central point of failure. If the broker goes down, all the workers are not able to do their work. This can make it very hard to scale the system, as you need to make sure that the broker can handle the load of all the requests that are coming in. (We can however use a truly distributed broker like Kafka, but this is not trivial to setup and maintain.)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="latency">Latency<a href="#latency" class="hash-link" aria-label="Direct link to Latency" title="Direct link to Latency">​</a></h3><p>As all connections have to be routed through the broker, there is a latency penalty. This is not always a big problem, as the latency penalty is very small, but it is still quite a penalty if your application is latency sensitive, and could have connected directly to the worker.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hard-to-advertise-functionality">Hard to advertise functionality<a href="#hard-to-advertise-functionality" class="hash-link" aria-label="Direct link to Hard to advertise functionality" title="Direct link to Hard to advertise functionality">​</a></h3><p>As the broker is just made to route messages, it does not know what functionality is available on the workers. This means that the workers need to advertise their functionality to a central repository of all functionality that is available. This necessates a common protocol often interface definition language (IDL) to be used by all workers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hard-to-setup">Hard to setup<a href="#hard-to-setup" class="hash-link" aria-label="Direct link to Hard to setup" title="Direct link to Hard to setup">​</a></h3><p>The initial setup of the broker is not trivial, as you need to be familiar with the technology.</p><h1>The decision on the architecture</h1><p>It was not an easy decision to make, but we decided to go with the message-based RPC protocol. We believe that the advantages of the message-based RPC protocol outweigh the disadvantages (in our specific use case). Arkitekt is a platform that wants to focus on the functionality of the applicationn, and provide a secure and easy to use platform. We believe that the message-based RPC protocol is the best fit for this use case. But lets look at our design in more detail.</p><p>~ Image of discovry protocol, side by side with assignment protocol ~</p><p>In our design the arkitekt platform (indeed its <code>rekuest</code> service) is the central broker, that negotiates between your applications. As discussed previously, we need a central repository for our functionality, that all applications can publish to and read from. With <code>rekuest</code> we also provide this and enable apps to simply publish their functionality when connecting to the platform. This functionality is then available to all other apps that are connected to the platform in the form of a Template implementing a Node. See the <a href="/doks/docs/design/terminology/template">Template</a> section for more information on this. The application now when put into
the provide mode, will connect to the central broker as an agent (worker). This agent is now uniquely identified by the user, and the oauth2 client as well as an instance_id (If you would like to use multiple instances of the same application). The agent now represents a stateful connection to the broker, and we can track the state of all of the agents on the platform.</p><p>Importantly the agent does not listen to any requests by itself, but will only do so when receiving a provision. (see figure2). A provision is the act of requesting a specific functionality of an applicaiton through the broker. It represents a contract between the application and the broker. The application can choose to respect this contract, or not (e.g when it can&#x27;t ensure the requested resources are available). </p><p>Clients trying to use the functionality of an application, will connect to the broker, and request a reservation. A reservation is a request to the broker to make a specific functionality available for the client. Again its a contract between the broker and this time the client. The broker will then try to find an application that provided the functioniality (already exisiting provision) or provide this functionality (creating a provision) on another app. This provision is then linked to the reservation. </p><p>When now requesting to use the functionality (doing the RPC call itself), the client will send a request through its connection to the reservation which will in turn map this request to the provision. The provision will then send the request to the agent, which will then execute the request and return the result to the provision, which will then return the result to the reservation, which will then return the result to the client. </p><p>We establish these contracts as core elements of our design as they allow a clear seperation between the client and the worker. Additionaly these contracts
allow the client to determine the conditions of validity of its contract to use the functionality (e.g demanding multiple workers to be available, which apps
are allowed to provide the functionality, etc). This enables easy debugging of the system, as the broker can tell you what is going on.</p><p>Internally these contracts mimic closely the concepts of topics and queues in message-based systems. The reservation is the topic, and the provisions are the queues that are subscribed (in a round-robin manner) to the topic. The client send messages to the topic and they get mapped to the queue.</p><p>~ Extended image of the broker RPC with arkitekts, reservation and provision ~</p><p>Lets look at the image above. We see that the broker is still the central point of authority, and both the application providing functionality and the client are connecting to it, through stateful connections. However we introduce the concept of reservations and provisions</p><h1>Going asynchronous</h1><p>One of the most important decisions when choosing to use an RPC protocol is choosing how you want to interface with your application. Do you want to use synchronous or asynchronous calls?</p><p>Synchronous RPC calls are blocking. The client will wait for the server to return the result before it can continue. Asynchronous RPC calls are non-blocking. The client will not wait for the server to return the result before it can continue. </p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_S0QG"><p>Notice, that this behaviour is completely orthogonal to the design of the protocol. It possible to use synchronous or asynchronous calls both in a message-based RPC protocol and in a client-server protocol. In a message-based RPC protocol, the client can send a request to the broker, and then wait for the broker to return the result. Or the client can send a request to the broker, and then continue with its work. The broker will then send the result to the client when it is ready.</p></div></div><p>Even though we provide you with synchronous interface in our client-libraries, arkitekt is designed to be asynchronous, which allows you to easily design
concurrent workflows, </p><h1>The request/response cycle</h1><h1>The message-based RPC</h1><h1>The &#x27;client-focus&#x27; RPC</h1></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/jhnnsrs/doks/edit/master/docs/design/arkitekt-rpc.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doks/docs/category/design"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Design</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doks/docs/design/middleman"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Middleman</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-is-an-rpc-protocol" class="table-of-contents__link toc-highlight">What is an RPC protocol?</a><ul><li><a href="#the-landscape-of-rpc-protocols" class="table-of-contents__link toc-highlight">The landscape of RPC protocols</a></li></ul></li><li><a href="#advantages-of-the-client-server-rpc" class="table-of-contents__link toc-highlight">Advantages of the &#39;client-server&#39; RPC</a><ul><li><a href="#easy-to-understand" class="table-of-contents__link toc-highlight">Easy to understand</a></li><li><a href="#fast-to-setup" class="table-of-contents__link toc-highlight">Fast to setup</a></li><li><a href="#easy-to-scale" class="table-of-contents__link toc-highlight">Easy to scale</a></li><li><a href="#easy-to-advertise-functionality" class="table-of-contents__link toc-highlight">Easy to advertise functionality</a></li></ul></li><li><a href="#disadvantages-of-the-client-server-rpc-in-the-arkitekt-context" class="table-of-contents__link toc-highlight">Disadvantages of the &#39;client-server&#39; RPC in the Arkitekt context</a><ul><li><a href="#not-always-suitable-for-a-distributed-environment" class="table-of-contents__link toc-highlight">Not always suitable for a distributed environment.</a></li><li><a href="#not-easy-to-scale" class="table-of-contents__link toc-highlight">Not easy to scale</a></li><li><a href="#not-easy-to-debug" class="table-of-contents__link toc-highlight">Not easy to debug</a></li><li><a href="#hard-to-protect" class="table-of-contents__link toc-highlight">Hard to protect</a></li></ul></li><li><a href="#advantages-of-the-message-basedbroker-rpc" class="table-of-contents__link toc-highlight">Advantages of the &#39;message-based&#39;/&#39;broker&#39; RPC</a><ul><li><a href="#easy-to-configure" class="table-of-contents__link toc-highlight">Easy to configure</a></li><li><a href="#easy-to-debug" class="table-of-contents__link toc-highlight">Easy to debug</a></li><li><a href="#easy-to-protect" class="table-of-contents__link toc-highlight">Easy to protect</a></li><li><a href="#easy-to-scale-to-and-recover" class="table-of-contents__link toc-highlight">Easy to scale to and recover</a></li></ul></li><li><a href="#the-disadavantages-of-the-message-based-broker" class="table-of-contents__link toc-highlight">The disadavantages of the message-based broker</a><ul><li><a href="#centralized-broker" class="table-of-contents__link toc-highlight">Centralized broker</a></li><li><a href="#latency" class="table-of-contents__link toc-highlight">Latency</a></li><li><a href="#hard-to-advertise-functionality" class="table-of-contents__link toc-highlight">Hard to advertise functionality</a></li><li><a href="#hard-to-setup" class="table-of-contents__link toc-highlight">Hard to setup</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doks/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/arkitekt" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/arkitekt" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/arkitekt" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doks/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/jhnnsrs/doks" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Arkitekt, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/doks/assets/js/runtime~main.909a4a31.js"></script>
<script src="/doks/assets/js/main.f18b54af.js"></script>
</body>
</html>