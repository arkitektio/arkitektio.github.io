---
id: installation
title: Installation
sidebar_label: Installation
sidebar_position: 1
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Getting Started!

The easiest way to install the library is to use poetry or pip:

```python
pip install "arkitekt[all]"
```

This will install the library with all its dependencies, including the Arkitekt
CLI as well as all supporting libraries for each service.

This is the recommend way to install arkitekt, especially if you are not planning
to use arkitekt as a dependency in another project.

:::info Modular Arkitekt
If you are planning to only
use arkitekt as a dependency in another project, you can install it without the
CLI and add it additional dependencies as needed.

```python
pip install arkitekt
# pip install mikro (for microscopy support)
# pip install rekuest (for registering nodes)
```

:::

## Choose your tutorial

The best way to explore what Arkitekt can do is to follow one of the tutorials.
Here you can find a list of tutorials that will guide you through the process of
creating your first app. But first let's discuss the two different styles of developing
apps with Arkitekt.

- Classic

This is the most straight-forward way of **interacting** with Arkitekt and its
services if you want to interact and explore your data, and **use** functionality from other apps.
The Arkitekt API here sits in the background just like any other python library, and you
are in full control of the execution of your code.

- Integrated

App that follow the `integrated style` are more integrated into the Arkitekt ecosystem. When developing
an integrated app, the Arkitekt CLI takes more control over your development process, in order to streamline
the process of developing and publishing apps that **provide new functionality** (nodes). It also highly
automates the process of **publishing** your app , so that it can be used by other users.

While you easily switch between the two styles, they differ in the way you interact with the Arkitekt API.

## Classic

Classic apps are the most straight-forward way of interacting with the Arkitekt API. Here is an example:

```python
from arkitekt import easy
from mikro.api.schema import from_xarray
import numpy as np

# whatever python code

with easy("my_little_app",  url="http://localhost:8000"):
    # do stuff with the arkitekt api
    # new image
    img = np.random.rand(100, 100)
    image = from_xarray(img, name="my_image") # uploads image to the mikro service

# Whatever python code

```

This is a very simple example of how you can use the Arkitekt API to interact with the
services. Here we are creating an "easy" app (more about that later) and then we are
creating a new image and uploading it to the mikro service. Once we leave the context
manager, the app is automatically closed and your script can continue to run as usual.
Also you run this like any other python script, without any additional steps.

## Integrated

```python
from arkitekt import register
from mikro.api.schema import from_xarray, RepresentationFragment

@register
def create_random_image(x_size: int, y_size: int) -> RepresentationFragment:
    """ Random Image

    Creates a random image with the given size.

    Parameters
    ----------
    x_size : int
        The size of the image in x direction.
    y_size : int
        The size of the image in y direction.

    Returns
    -------
    RepresentationFragment
        The created image.
    """

    img = np.random.rand(100, 100)

    return from_xarray(image, "Random Image")


if __name__ == "__main__":
    # here you can run other code, that
    # will not be executed when the app is
    # run by the arkitekt cli
    pass

```

Here we are creating an app that can be run by the Arkitekt CLI and that
provides a Node (Add two Numbers) that can be used by other apps. The
`@register` decorator is used to mark a function as a node. The function
itself is a normal python function. Importantly when running this script
normally with `python`, the code in the `if __name__ == "__main__"` block will be executed,
but none of the code in the function will be executed. Only when you run this
script with the Arkitekt CLI `arkitekt run` the function will be registered
as a node through the Arkitekt API.

:::info Why do we use this?

This pattern might seem strange at first, but it has a few advantages, that we will
get into later. The main reason is that it allows us to enable a lot of automation,
and some nice developer experience features like hot-reloading, but most importantly
it allos us to make the process of developing and publishing apps as easy as possible.
:::
